1.程序计数器

程序计数器是一块较小的内存区域，它可以看做是当前线程所执行字节码的一个行号指示器，在java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个程序计数器来选取下一条需要执行的字节码指令，他是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成，由于java虚拟机的多线程是用过轮流切换，使用分配到的cpu时间的方式来实现的，在一个确定的时刻，一个处理器只能执行一条线程中的指令，因此，为了线程切换后能回到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程的程序计数器之间互相不影响，独立存储，所以程序计数器这块区域是线程所私有的内存区域，如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码，如果是一个本地方法，这个计数器值则应该为空，undefined。

注意：程序计数器是java虚拟机规范中唯一一个没有规定任何oom情况的内存区域

2.java虚拟机栈

与程序计数器一样，java虚拟机栈也是线程所私有的一块内存区域，它的生命周期是和线程相同的，虚拟机栈描述的是java方法执行的线程内存模型，每个方法被执行的时候，虚拟机栈都会同步创建一个栈帧用于存储局部变量表，操作数栈，动态连接，方法出口等信息，每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。

局部变量表存放了编译期可知的各种java虚拟机基本数据类型，对象引用类型，（它并不等同于对象本身，可能是指向对象起始位置的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）的return address类型，（指向了一条字节码指令的地址）

这些数据类型在局部变量表中以局部变量槽slot来存储，其中64位长度的long和double类型的数据占用两个局部变量槽，其余数据类型只会占用一个，局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法的时候，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的。在方法运行期间不会改变局部变量表的大小，这里注意，这个大小指的是slot槽位的个数，具体每个slot分配多少的内存空间完全是由具体的虚拟机所决定的。

在java虚拟机规范中，对这个内存区域规定了两类异常状况，如果线程请求的栈深度大于虚拟机栈所允许的深度，那么就会抛出stackoverflow，如果虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存时，就会抛出oom异常

但是需要注意在hotspot虚拟机中，是不允许虚拟机栈的容量进行动态扩展的，也就是说不会出现上述的oom情况，但是如果线程在申请栈空间失败时，仍然会抛出oom，不是无法动态扩展而抛出的oom

3.本地方法栈

本地方法栈与虚拟机栈类似，区别是虚拟机栈是为java执行字节码服务，而本地方法栈是为虚拟机用到的本地方法native方法做一个服务，在hotspot虚拟机中，合并了虚拟机栈和本地方法栈。本地方法栈也会抛出oom和Stack Overflow

4.堆

堆是虚拟机创建的最大的一块内存区域，同时他也是所有线程所共享的一块内存区域，java虚拟机规范中对堆的描述是：几乎所有的对象实例以及数组对象都会在堆上分配内存空间，但是随着即时编译技术的进步，尤其是逃逸分析的存在，目前并不是所有的对象实例都会在堆上进行内存分配，堆也是oom的重灾区，也是GC机制最主要处理的内存区域。在jdk及以前，堆内存主要划分为新生代，老年代和永久代，因为java虚拟机规范对于方法区只是给出了它的概念和作用，并没有要求具体该怎么实现，jdk7及以前，方法区的具体实现就是永久代，到了jdk8及以后，方法区改为了元空间，使用直接内存。所以堆内部只剩下了年轻代和老年代，年轻代又分为eden区和s0区以及s1区

5.方法区

方法区与堆一样，是各个线程所共享的内存区域，它用于存储被虚拟机加载的类型信息，常量，以及静态变量，jit编译器编译后的代码缓存等，这个区域也会有oom，但是这个区域的GC的成本很高，GC所造成的收益不明显，尤其时对类型的卸载，条件是相当苛刻的。

为什么将永久代移除，改为元空间？

由于hotspot与JRockit和j9的方法区实现不一致，因为这种差异而遇到了很多困难，考虑到hotspot虚拟机未来的发展，最终在jdk7去永久代化的过程中先将字符串常量池以及静态变量

JDK7以上，静态变量存储在其对应的Class对象中。而Class对象作为对象，和其他普通对象一样，都是存在java堆中的。

使用了元空间后，与永久代最大的不同是由于使用了直接内存，如果不通过参数的设置，随着更多类的创建，虚拟机会耗尽所有的可用内存。

6.运行时常量池

运行时常量池是方法区的一部分，class文件中除了有类型信息，字段，方法，接口等描述信息外，还有一项就是常量池表，用于存放编译器生成的各种字面量以及符号引用，这部分内容将在类加载完成以后放到方法区的运行时常量池中

jdk7以前，运行时常量池包含字符串常量池放在方法区中，此时hotspot虚拟机对方法区的实现为永久代。

到了jdk1.7，字符串常量被从方法区拿到了堆中，这里没有提到运行时常量池，也就是说运行时常量池剩下的东西还在，只是字符串常量池被移到了堆中

jdk8将方法区的实现变为了元空间，字符串常量池在堆，运行时常量池在方法区，方法区的具体实现成了元空间

7.直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，但是由于使用的比较频繁，以及会出现oom，所以还是要关注学习。主要是jdk4引入NIO后，channel和buffer的io方式，它可以直接使用native函数库来直接分配堆外内存，然后通过存储在堆里面的java对象directbytebuffer来作为这个内存的引用进行操作，这在一些场景中是能显著提升效率的

### java对象的创建

1.类加载检查，首先java虚拟机遇到一条new指令，会先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已被加载，连接和初始化过。如果没有，先执行相应的类加载过程

2.分配内存

对象所需的内存在类加载完成以后其实就已经确定下来了，为对象分配内存空间，等同于把一块确定大小的内存空间从java堆中划分出来，内存分配有指针碰撞和空闲列表两种，选择哪种分配方式取决于java堆是否规整，因为指针碰撞的原理是：假如堆内存绝对工整，所有被使用的内存空间在一边，未被使用的空间在另一边，中间放着一个指针，分配内存就是把指针指向空闲空间方向然后挪动与对象所需内存大小相等的一段距离，这种分配方式就叫指针碰撞，但是如果java堆内存时不规整的，就是用空闲列表，空闲列表的原理是：虚拟机维护一张列表，记录哪些内存块是可用的，在分配的时候直接取一块足够的空间分配给对象实例，然后更新列表上的记录，如果选用的垃圾回收器带有压缩整理功能，比如parnew和serial，系统就会采用指针碰撞的分配方式。如果采用cms这种基于清除算法的垃圾回收器，那么就会采用空闲列表

使用指针碰撞这块有一个小的注意点，由于对象的创建是一个非常频繁的操作，如果多线程并发访问的话，可能会有线程安全的问题，虚拟机采用的方案又两种：1.CAS加失败重试机制来保证分配内存的原子性 2.使用本地线程分配缓冲，TLAB，即每个线程在java堆中预先分配一小块内存，哪个线程在创建对象的时候要分配内存了，就在自己的内存中操作。

3.初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，不包括对象头，这一步操作保证了对象的实例字段在java代码中可以不赋初始值就可以直接使用，程序是能直接访问到这些字段的数据类型所对应的初始值

4.设置对象头

初始化零值完成以后，虚拟机会对对象进行必要的设置，例如这个对象属于哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息，这些信息放在java的对象头中，另外会根据虚拟机参数的设置，比如是否启用偏向锁，对象头中会有不同的设置

5.执行init方法

在上面工作完成以后，从虚拟机的视角看，一个对象就已经产生了，但从java程序的视角来看，对象才刚开始创建，new指令以后，紧跟着要执行构造方法，将对象实例按照程序员自己的意愿来创建出来。

### 对象的内存布局

在hotspot虚拟机中，对象的内存布局可以分为三个部分：对象头，实例数据，对齐填充。

对象头又分为两部分，一种是存储自身运行数据的mark word，（哈希码，GC分代年龄，锁状态标志等等），另一部分就是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

在jdk8及以后是默认开启指针压缩，开启指针压缩以后这个指针占4个字节，关闭指针压缩的话占8个字节

实例数据是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容

对齐填充不是必须的，也没有什么特别的含义，仅仅起到占位的作用，因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全



