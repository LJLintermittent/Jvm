逃逸分析是为其他优化措施提供依据的一种分析技术

逃逸分析的基本原理的是：当一个对象在方法里面被定义以后，他可能被外部方法所引用，比如在这个方法内部通过另一个方法以参数传递的形式，来被其他方法引用，这种称为方法逃逸，甚至采用异步编排，还可能被其他线程所引用，称为线程逃逸，如果一个对象不会逃逸到方法或线程之外，那么就可以使用相应的后端编译优化，比如：栈上分配，标量替换，同步消除

### 栈上分配

在虚拟机中，一般对象实例的创建都会在堆上分配内存空间，而堆中的对象是被所有线程所共享的，只要持有这个对象的引用，就可以访问到堆中的数据，然后垃圾回收器主要是回收堆中不被引用的对象，在回收的过程中，不论是可达性分析阶段还是使用各种算法进行清除，都会产生消耗，所以如果确定一个对象不会逃逸出线程外，因为虚拟机栈是线程独享的，那么可以将对象分配在栈空间中，从而随着方法的调用结束，栈帧出栈以后，对象也就随之销毁，那么垃圾回收系统的压力就会降低很多。因为要分配在栈空间，是线程独享，所以必须经过逃逸分析确定对象是否逃逸出本线程，对是否逃逸出方法这个不做要求

### 标量替换

标量的意思是在虚拟机中一个不可以再被分割的数据类型，比如，int，long，reference等都不可以再被分割了，那么这些数据类型就称为标量，相对的，如果一个数据可以继续分解，那么这个数据类型被称为聚合量，对象就是典型的聚合量，所以如果经过逃逸分析得出这个对象不会逃逸出方法后，并且根据程序的访问情况，来对这个对象进行拆分，将真正被使用到的成员变量放到栈中，所以标量替换直接不创建对象，把对象的成员变量分配在栈空间上，由于也是在栈空间上分配和读写，所以标量替换可以看做是栈上分配的一种特例，但是需要逃逸分析出对象不会逃逸出线程及方法，逃逸方法的要求比逃逸线程的要求高

### 同步消除

线程同步本身是一个相对耗时的过程，如果逃逸分析后能够确定一个对象不会逃逸出线程，无法被其他线程所访问，那么这个变量的读写肯定不会受到竞争，所以对这个变量的同步措施可以安全的消除

但是逃逸分析目前还未完全成熟，并且目前的技术方案下的逃逸分析的分析算法非常复杂，计算成本很高，甚至所带来的收益还无法抵消它计算花去的时间。