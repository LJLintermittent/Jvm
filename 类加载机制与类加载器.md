### 类加载的时机

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载，链接(验证，准备，解析)，初始化，使用，卸载这几个阶段。需要注意的是解析阶段不一定是按部就班的顺序进行，解析阶段有可能在初始化阶段之后才开始

关于什么时候开始一个类的加载，java虚拟机规范中并没有明确的定义，这点可以交给虚拟机来自由实现，但是在初始化阶段，java虚拟机严格规定了六种情况必须立刻对类进行初始化，当然加载，验证，准备必然是在初始化前面就执行了

1.遇到new（创建对象），getstatic(获取类的静态域，并将其压入栈顶)，putstatic(为类的静态域赋值)以及invokestatic（调用类的静态方法）这四个字节码指令的时候，如果类型没有初始化，那么需要立即进行初始化

2.对类型进行反射调用的时候，如果类型没有初始化，需要先进行初始化

3.在初始化一个类的时候，如果这个类的父类还没有初始化过，那么会先触发其父类的初始化

4.当虚拟机启动的时候，用户需要指定一个要执行的主类，也就是包含main方法的那个类

5.当一个接口中定义了jdk8新加入的default默认方法，如果有这个接口的实现类发生了初始化，则这个接口应该在这个类初始化之前进行初始化

6.当使用jdk7新加入的动态语言支持时，如果一个methodhandler实例最后的解析结果为getstatic,putstatic ,invokestatic, newinvokespecial这四种类型的方法句柄时，如果这个方法句柄对应的类没有进行初始化过，那么要先对该类进行初始化

### 加载

加载是类加载过程的第一步，主要完成三件事：

1.通过一个类的全限定名来获取定义此类的二进制字节流

2.将字节流所代表的静态存储结构转换为方法区的运行时数据结构

3.在内存(堆内存)中生成一个代表该类的Class对象，作为方法区这些数据的访问入口，这句话就是反射的原理

一个非数组类的加载阶段是可控性最强的阶段，这一步我们自定义加载器去控制字节流的获取方法，重写一个类的loadclass()方法，数组类型不通过类加载器创建，而是通过虚拟机直接创建

在加载阶段结束以后，虚拟机外部的二进制字节流就会按照虚拟机所设定的格式存储在方法区中了，类型数据妥善保存在方法区中以后，会在堆空间中创建一个该类型的Class对象实例，这个对象作为程序访问方法区中的类型数据的外部接口，就是反射的实现

### 验证

验证阶段的目的是确保Class文件的字节流中包含的信息是否符合虚拟机规范，保证这些信息被当做代码交给虚拟机运行后不会危害虚拟机自身的安全，由于加载阶段和连接解阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段就已经开始。

1.文件格式验证：

验证字节流是否符合java虚拟机规范，比如是否是以魔数开头，主次版本号是否在当前虚拟机的处理范围之内，常量池中是否有不被支持的常量类型，由于验证可能会跟加载交叉进行，所以经过了文件格式验证后，才会真正将这段二进制字节流放到方法区内存中。

2.元数据验证：

对字节码描述的信息进行语义分析，来保证其描述信息符合java语言的规范要求，比如这个类的父类是否继承了不该继承的类，(被final修饰的类)元数据验证的主要目的就是对元数据信息进行语义校验

3.字节码验证：

最复杂的一个阶段，通过数据流和控制流分析，确定程序语义是否是合法的，符合逻辑的，比如要保证任意时刻操作数栈和指令代码序列都能配合工作，通俗的将就是前面元数据验证完了以后，确定了这个类的元数据信息，那么字节码验证就该到验证具体方法的时候了，比如我要检查一个方法体中的类型转换是否总是正确有效的，例如我把一个子类对象赋值给父类数据类型，也就是父类引用指向子类，就是多态的具体表现，是正确的，但是如果我把子类引用指向父类对象就不行，所以字节码验证阶段主要就是验证代码部分的程序语义是否正确

4.符号引用验证：

确保解析动作能够正确执行，因为在解析阶段需要将符号引用转换为直接引用

具体比如：我要通过符号引用中(符号引用可以就可以当做一个任意字面量)字符串的描述的全限定名看能否找到相对应的类

### 准备

准备阶段是正式为类变量分配内存以及为类变量设置初始值的阶段，这些内存都将在方法区进行分配(静态变量？)，不过特别需要注意：

1.这时候进行内存分配的仅包括类变量，即静态变量，而不包括实例变量，实例变量会在对象实例化以后跟随对象一起放在堆内存中

2.从概念上将，类变量(静态变量)所使用的内存应该是跟随类的元数据信息一起在方法区进行分配的，如果是jdk7以前，这种逻辑完全符合永久代的实现，而在jdk7及以后，在去永久化的过程中，将字符串常量池和静态变量一起移到了堆中，所以在准备阶段为类变量分配内存会分配到堆内存中

3.这里所设置的初始值"通常情况"下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。

### 解析

解析阶段是虚拟机将运行时常量池中的符号引用替换为直接引用的过程，解析动作主要针对类，接口，类方法，接口方法，方法类型，方法句柄和调用限定符这7类符号引用进行

符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

综上，解析阶段是虚拟机将运行时常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

### 初始化

初始化阶段是执行初始化方法<clinit>（）方法的过程，是类加载的最后一步，这一步jvm才开始真正执行定义在类中的java程序代码，其实是字节码，需要注意的是clinit方法是编译以后自动生成的，这个方法加了锁，所以多线程环境下进行类的初始化可能会引起多个线程阻塞。

### 卸载

卸载一个类即这个类的Class对象被GC，卸载类需要满足三个要求：

1.首先这个类的所有实例及其派生子类的实例都已经被GC

2.该类没有在其他任何地方引用

3.该类的类加载器都已经被GC

只要想通一点就好了，jdk 自带的 `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

### 类加载器

类加载器虽然只用于实现类的加载动作，但是它非常重要，对于任意一个类，都必须由类加载器以及这个类本身一同确立其在java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间

加载器加载的作用就是将.class文件加载到方法区，直接内存

JVM内置了三个类加载器，分别是：

1.**BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由 C++实现，负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类

2.**ExtensionClassLoader(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包

3.**AppClassLoader(应用程序类加载器)** ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类