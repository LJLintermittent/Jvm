针对hotspot虚拟机的GC，我认为只有两大类GC：

1.非整堆GC，partial GC 

2.整堆 + 方法区的GC full GC 

对于所谓的old gc，也就是只收集老年代，只有cms的concurrent collection是这个模式

对于mixed gc，也就是收集全部年轻代加上部分老年代，只有G1有这个模式

对象优先在年轻代分配，更准确的说是年轻代中的eden区

大对象直接进入老年代，这样做是为了避免空间分配担保策略以及后面gc的复制带来的性能的降低

### 空间分配担保

空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。

jdk6之前，在发生minor gc 之前，会检查老年代中是否有足够的连续内存空间来存放新生代的所有对象，如果这个条件，说明这个minor gc是没有风险的，如果不成立，虚拟机会检查空间分配担保参数，看参数的设置是否允许失败，如果允许失败，会继续检查历次晋升到老年代的对象的平均大小，如果老年代目前连续的可用内存空间大于这个平均大小，就会进行minor gc ，尽管这次是有风险的，但是如果参数设置不允许有风险，或者老年代的可用空间还没有平均值大，那么直接full gc

jdk6以后规则变为只要老年代连续空间大于新生代对象总大小或者历次晋升老年代的对象的平均大小，就会进行minor gc，否则full gc

###  引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。** 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们

###  可达性分析算法

从一系列被称为GCroots的对象作为起点，从这些节点开始向下搜索，节点所走过的路被称为引用链，当一个对象到GCroots之间没有任何引用链相连的话，则证明对象是不可用的

可作为GC的对象有：

1.虚拟机栈，准确的说是虚拟机栈的栈帧中的局部变量表中的对象引用所指向的对象，我的理解是方法的调用和结束就是一个栈帧入栈和出栈的过程，那么在当前线程执行方法时，这个方法中所引用的对象当然比如是存活的，所以它可以被作为GCroots，去调查别的对象是否还是可用的

2.本地方法栈native方法引用的对象

3.方法区中静态变量所引用的对象

4.方法区中常量所引用的对象

5.所有被同步锁持有的对象

### 方法区的垃圾回收

方法区垃圾回收主要收集的类型是废弃的常量和不再使用的类。

判断一个不再使用的类的条件是非常严苛的：

1.判断该类的所有实例已经被回收，也就是java堆中不存在任何该类及其子类的实例对象

2.加载该类的类加载器都已经被回收了。

3.该类对应的Class对象没有在任何地方被引用，也就是说无法在任何地方通过反射来获取该类及其内部方法了