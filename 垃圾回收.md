针对hotspot虚拟机的GC，我认为只有两大类GC：

1.非整堆GC，partial GC 

2.整堆 + 方法区的GC full GC 

对于所谓的old gc，也就是只收集老年代，只有cms的concurrent collection是这个模式

对于mixed gc，也就是收集全部年轻代加上部分老年代，只有G1有这个模式

对象优先在年轻代分配，更准确的说是年轻代中的eden区

大对象直接进入老年代，这样做是为了避免空间分配担保策略以及后面gc的复制带来的性能的降低

### 空间分配担保

空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。

jdk6之前，在发生minor gc 之前，会检查老年代中是否有足够的连续内存空间来存放新生代的所有对象，如果这个条件，说明这个minor gc是没有风险的，如果不成立，虚拟机会检查空间分配担保参数，看参数的设置是否允许失败，如果允许失败，会继续检查历次晋升到老年代的对象的平均大小，如果老年代目前连续的可用内存空间大于这个平均大小，就会进行minor gc ，尽管这次是有风险的，但是如果参数设置不允许有风险，或者老年代的可用空间还没有平均值大，那么直接full gc

jdk6以后规则变为只要老年代连续空间大于新生代对象总大小或者历次晋升老年代的对象的平均大小，就会进行minor gc，否则full gc

###  引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。** 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们

###  可达性分析算法

从一系列被称为GCroots的对象作为起点，从这些节点开始向下搜索，节点所走过的路被称为引用链，当一个对象到GCroots之间没有任何引用链相连的话，则证明对象是不可用的

可作为GC的对象有：

1.虚拟机栈，准确的说是虚拟机栈的栈帧中的局部变量表中的对象引用所指向的对象，我的理解是方法的调用和结束就是一个栈帧入栈和出栈的过程，那么在当前线程执行方法时，这个方法中所引用的对象当然比如是存活的，所以它可以被作为GCroots，去调查别的对象是否还是可用的

2.本地方法栈native方法引用的对象

3.方法区中静态变量所引用的对象

4.方法区中常量所引用的对象

5.所有被同步锁持有的对象

### 方法区的垃圾回收

方法区垃圾回收主要收集的类型是废弃的常量和不再使用的类。

判断一个不再使用的类的条件是非常严苛的：

1.判断该类的所有实例已经被回收，也就是java堆中不存在任何该类及其子类的实例对象

2.加载该类的类加载器都已经被回收了。

3.该类对应的Class对象没有在任何地方被引用，也就是说无法在任何地方通过反射来获取该类及其内部方法了

### Serial

Serial是一个单线程的垃圾回收器，并且是一个新生代的垃圾回收器，Serial回收器所使用的回收算法是标记复制算法，串行回收，以及存在stw现象。这个收集器是一个单线程的收集器，即垃圾回收的时候只有一个垃圾回收线程在工作，特点是简单高效，对于单核处理器或者处理器核心数较少的机器，Serial由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的垃圾回收效率。Serial收集器对于运行在客户端模式下的虚拟机是一个较好的选择

### Serial Old

与Serial基本一致，只是这个垃圾回收器是针对老年代的回收的，在老年代回收采用的是标记整理算法。这个收集器存在的意义是在jdk5以前作为parallel scavenge的组合，以及如果cmd发生了失败，这个垃圾收集器会作为一个兜底的选择

### ParNew

ParNew收集器实际上是serial的多线程版本，其余设计基本一致，所以它也是一款新生代垃圾收集器，并且算法也是标记复制，parnew之所以出名的原因是它可以配合CMS垃圾收集器形成组合，cms是一款真正意义上实现了并发的垃圾回收器，也就是说垃圾回收线程可以和用户线程一起执行，应用程序依然能响应，只不过在垃圾回收的时候会占用线程资源，所以应用的吞吐量会受到一定的影响。cms只能与parnew或者serial组合，并且在jdk9 G1开始，官方就取消了cms和serial的组合，如果要是用cms，只能搭配parnew来使用

### parallel scavenge

parallel scavenge也是一款新生代垃圾回收器，同样是基于标记复制算法，同样是一个并行的多线程垃圾回收器，它与parnew比较相似，只不过这款垃圾回收器最大的特点就是关注吞吐量。所谓的吞吐量就是处理器用于运行用户代码的时间与处理器执行的总时间的比值，这个总时间包括垃圾回收时间和运行代码时间。parallel scavenge提供了两个参数来精确控制用户是想关注响应时间还是系统吞吐量，关注延迟的参数传进来一个大于0的毫秒值，表示回收器尽力在这个时间内完成垃圾回收，关注吞吐量的参数垃圾收集时间占总时间的比率。同时还有一个参数是开启自适应调节策略，只需要配置好基本的内存设置以及你是更关注最大停顿时间还是吞吐量参数，最终交给虚拟机自动调节

### parallel Old

parallel old是ps的老年代版本，支持多线程并行工作，在老年代的收集算法也是标记整理。在很长的一段时间，parallel sc 一直没有一个很好的老年代收集器来配合它，只能使用serial old。因为cms无法适配，但是serial old在高规格的机器环境下表现不加，是一个累赘，所以parallel old的出现才是真正弥补了吞吐量优先的垃圾收集器组合。有了parallel old后，在关注吞吐量的场景或者处理器资源比较稀缺的情况下，都可以使用ps+po的组合，这也是jdk8的官方默认垃圾回收器组合。

### CMS

cms的思路是以最低的延迟来回收垃圾，所以从名字就可以看出来，这是一款并发的采用标记清除算法的老年代垃圾回收器，并发的意思是垃圾收集线程可以与用户线程一起工作。

cms的主要过程可以分为四步：

1.初始标记

2.并发标记

3.重新标记

4.并发清除

其中在初始标记阶段和重新标记阶段依然需要stw，但是由于初始标记阶段仅仅是标记GCroots所能直接引用到的对象，所以这个过程非常快，那么重新标记则是为了修改并发标记期间因为用户线程依然在运行所造成的标记产生变动的那一部分对象的标记记录，这个阶段的停止时间通常会比初始标记阶段长，但是也远比最耗时的并发标记阶段所用的时间短，整个过程最耗时的并发标记与并发清除都是与用户线程并发运行的。

cms的缺点：

1.cms对处理器资源比较敏感，它的默认启动回收线程数是(处理器核心数 + 3 )/ 4，如果处理器的核心数量不足四个的时候，cms对用于线程的影响是比较大的，当机器大于四核时，并发回收的线程数只占用不到25％的资源。昙花一现的增量式cms，随着计算机的发展，这个缺点其实影响并不是很大。

2.由于cms收集器无法处理浮动垃圾，有可能出现并发失败而导致另一次完全stw的full gc的发生，由于并发标记阶段和并发清理阶段有用户线程在运行，只要有用户线程在运行，那么就会产生新的垃圾，即使在并发标记后还有一此重新标记，来试图挽回，但是最终并发清理阶段也就是并发的，这个阶段产生的垃圾只能留给下一次垃圾收集时在进行清理，这一部分垃圾就是浮动垃圾。还有一个问题是由于用户线程也在运行，那就需要预留足够的内存空间来给用户线程所使用，因此cms在垃圾回收的时候不能像其他垃圾收集器一样等到老年代几乎满了才开始运行，必须预留一部分空间供用户线程使用。

同样的，由于连锁反应，这个预留的空间如果不足的话，无法让用户线程分配新的对象，那么就会出现一次并发失败，这时候虚拟机将不得不冻结用户线程的执行，临时启用serial old这个兜底的老年代串行化单线程标记整理算法的垃圾回收器，这样的话停顿时间就很长了。

还有一个问题，由于cms使用的是标记清除算法，会产生内存碎片化问题，这个问题会导致在分配大对象的时候，可能会导致老年代没有足够大的连续空间来放这个大对象，而不得不提前触发一次full gc，cms的解决方案是在将要进行不得不进行的full gc前，进行一次内存碎片化整理，由于内存整理必须移动存活的对象，所以需要暂停用户线程，在shen和zgc出现之前这个内存整理动作是无法和用户线程并发的，所以虽然解决了碎片化问题，又衍生出了停顿时间长的问题。

G1



