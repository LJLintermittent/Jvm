针对hotspot虚拟机的GC，我认为只有两大类GC：

1.非整堆GC，partial GC 

2.整堆 + 方法区的GC full GC 

对于所谓的old gc，也就是只收集老年代，只有cms的concurrent collection是这个模式

对于mixed gc，也就是收集全部年轻代加上部分老年代，只有G1有这个模式

对象优先在年轻代分配，更准确的说是年轻代中的eden区

大对象直接进入老年代，这样做是为了避免空间分配担保策略以及后面gc的复制带来的性能的降低

### 空间分配担保

空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。

jdk6之前，在发生minor gc 之前，会检查老年代中是否有足够的连续内存空间来存放新生代的所有对象，如果这个条件成立，说明这个minor gc是没有风险的，如果不成立，虚拟机会检查空间分配担保参数，看参数的设置是否允许失败，如果允许失败，会继续检查历次晋升到老年代的对象的平均大小，如果老年代目前连续的可用内存空间大于这个平均大小，就会进行minor gc ，尽管这次是有风险的，但是如果参数设置不允许有风险，或者老年代的可用空间还没有平均值大，那么直接full gc

jdk6以后规则变为只要老年代连续空间大于新生代对象总大小或者历次晋升老年代的对象的平均大小，就会进行minor gc，否则full gc

###  引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。** 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们

###  可达性分析算法

从一系列被称为GCroots的对象作为起点，从这些节点开始向下搜索，节点所走过的路被称为引用链，当一个对象到GCroots之间没有任何引用链相连的话，则证明对象是不可用的

可作为GC的对象有：

1.虚拟机栈，准确的说是虚拟机栈的栈帧中的局部变量表中的对象引用所指向的对象，我的理解是方法的调用和结束就是一个栈帧入栈和出栈的过程，那么在当前线程执行方法时，这个方法中所引用的对象当然是确定要存活的，所以它可以被作为GCroots，去调查别的对象是否还是可用的

2.本地方法栈native方法引用的对象

3.方法区中静态变量所引用的对象

4.方法区中常量所引用的对象

5.所有被同步锁持有的对象

### 方法区的垃圾回收

方法区垃圾回收主要收集的类型是废弃的常量和不再使用的类。

判断一个不再使用的类的条件是非常严苛的：

1.判断该类的所有实例已经被回收，也就是java堆中不存在任何该类及其子类的实例对象

2.加载该类的类加载器都已经被回收了。

3.该类对应的Class对象没有在任何地方被引用，也就是说无法在任何地方通过反射来获取该类及其内部方法了

### Serial

Serial是一个单线程的垃圾回收器，并且是一个新生代的垃圾回收器，Serial回收器所使用的回收算法是标记复制算法，串行回收，以及存在stw现象。这个收集器是一个单线程的收集器，即垃圾回收的时候只有一个垃圾回收线程在工作，特点是简单高效，对于单核处理器或者处理器核心数较少的机器，Serial由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的垃圾回收效率。Serial收集器对于运行在客户端模式下的虚拟机是一个较好的选择

### Serial Old

与Serial基本一致，只是这个垃圾回收器是针对老年代的回收的，在老年代回收采用的是标记整理算法。这个收集器存在的意义是在jdk5以前作为parallel scavenge的组合，以及如果cmd发生了失败，这个垃圾收集器会作为一个兜底的选择

### ParNew

ParNew收集器实际上是serial的多线程版本，其余设计基本一致，所以它也是一款新生代垃圾收集器，并且算法也是标记复制，parnew之所以出名的原因是它可以配合CMS垃圾收集器形成组合，cms是一款真正意义上实现了并发的垃圾回收器，也就是说垃圾回收线程可以和用户线程一起执行，应用程序依然能响应，只不过在垃圾回收的时候会占用线程资源，所以应用的吞吐量会受到一定的影响。cms只能与parnew或者serial组合，并且在jdk9 G1开始，官方就取消了cms和serial的组合，如果要是用cms，只能搭配parnew来使用

### parallel scavenge

parallel scavenge也是一款新生代垃圾回收器，同样是基于标记复制算法，同样是一个并行的多线程垃圾回收器，它与parnew比较相似，只不过这款垃圾回收器最大的特点就是关注吞吐量。所谓的吞吐量就是处理器用于运行用户代码的时间与处理器执行的总时间的比值，这个总时间包括垃圾回收时间和运行代码时间。parallel scavenge提供了两个参数来精确控制用户是想关注响应时间还是系统吞吐量，关注延迟的参数传进来一个大于0的毫秒值，表示回收器尽力在这个时间内完成垃圾回收，关注吞吐量的参数垃圾收集时间占总时间的比率。同时还有一个参数是开启自适应调节策略，只需要配置好基本的内存设置以及你是更关注最大停顿时间还是吞吐量参数，最终交给虚拟机自动调节

### parallel Old

parallel old是ps的老年代版本，支持多线程并行工作，在老年代的收集算法也是标记整理。在很长的一段时间，parallel sc 一直没有一个很好的老年代收集器来配合它，只能使用serial old。因为cms无法适配，但是serial old在高规格的机器环境下表现不加，是一个累赘，所以parallel old的出现才是真正弥补了吞吐量优先的垃圾收集器组合。有了parallel old后，在关注吞吐量的场景或者处理器资源比较稀缺的情况下，都可以使用ps+po的组合，这也是jdk8的官方默认垃圾回收器组合。

### CMS

cms的思路是以最低的延迟来回收垃圾，所以从名字就可以看出来，这是一款并发的采用标记清除算法的老年代垃圾回收器，并发的意思是垃圾收集线程可以与用户线程一起工作。

cms的主要过程可以分为四步：

1.初始标记

2.并发标记

3.重新标记

4.并发清除

其中在初始标记阶段和重新标记阶段依然需要stw，但是由于初始标记阶段仅仅是标记GCroots所能直接引用到的对象，所以这个过程非常快，那么重新标记则是为了修改并发标记期间因为用户线程依然在运行所造成的标记产生变动的那一部分对象的标记记录，这个阶段的停止时间通常会比初始标记阶段长，但是也远比最耗时的并发标记阶段所用的时间短，整个过程最耗时的并发标记与并发清除都是与用户线程并发运行的。

cms的缺点：

1.cms对处理器资源比较敏感，它的默认启动回收线程数是(处理器核心数 + 3 )/ 4，如果处理器的核心数量不足四个的时候，cms对用于线程的影响是比较大的，当机器大于四核时，并发回收的线程数只占用不到25％的资源。昙花一现的增量式cms，在处理器资源不行的情况下，模拟单核处理器时代，使用多任务抢占式处理，快速交替回收线程与用户线程的工作，尽量减少垃圾收集线程独占资源的时间，随着计算机的发展，这个缺点其实影响并不是很大。

2.由于cms收集器无法处理浮动垃圾，有可能出现并发失败而导致另一次完全stw的full gc的发生，由于并发标记阶段和并发清理阶段有用户线程在运行，只要有用户线程在运行，那么就会产生新的垃圾，即使在并发标记后还有一此重新标记，来试图挽回，但是最终并发清理阶段也就是并发的，这个阶段产生的垃圾只能留给下一次垃圾收集时在进行清理，这一部分垃圾就是浮动垃圾。还有一个问题是由于用户线程也在运行，那就需要预留足够的内存空间来给用户线程所使用，因此cms在垃圾回收的时候不能像其他垃圾收集器一样等到老年代几乎满了才开始运行，必须预留一部分空间供用户线程使用。

同样的，由于连锁反应，这个预留的空间如果不足的话，无法让用户线程分配新的对象，那么就会出现一次并发失败，这时候虚拟机将不得不冻结用户线程的执行，临时启用serial old这个兜底的老年代串行化单线程标记整理算法的垃圾回收器，这样的话停顿时间就很长了。

还有一个问题，由于cms使用的是标记清除算法，会产生内存碎片化问题，这个问题会导致在分配大对象的时候，可能会导致老年代没有足够大的连续空间来放这个大对象，而不得不提前触发一次full gc，cms的解决方案是在将要进行不得不进行的full gc前，进行一次内存碎片化整理，由于内存整理必须移动存活的对象，所以需要暂停用户线程，在shen和zgc出现之前这个内存整理动作是无法和用户线程并发的，所以虽然解决了碎片化问题，又衍生出了停顿时间长的问题。

注意：

### 三色标记法

在并发标记阶段，由于垃圾收集线程与用户线程在这个时候是一块工作的，那么可能会出现并发标记完以后出错的情况，比如错误的把该消亡的对象标记成了存活对象，这个问题还好，只是产生了一个浮动对象，等下次垃圾回收的时候处理掉就好了，但是如果错误的把该存活的对象标记成了消亡对象，那么再清理了以后，程序肯定会因此发生错误。

根据三色标记法这个工具的演示，我们模拟了并发标记下对象消失的问题，最终得出一条结论，当且满足以下两个条件的时候，会产生对象消失的问题：

1.赋值器插入了一条或多条从黑色对象到白色对象的新引用

2.赋值器删除了全部的从灰色到白色对象的直接引用或者间接引用

那么我们只要破坏这两个条件之一，就可以解决并发扫描时遇到的对象消失问题，因此衍生出了两种解决算法，一种是增量更新，一种是原始快照，增量更新是破坏第一个条件，也就是在对黑色对象插入一条白色对象的引用时，将这个新插入的引用记录下来，等并发扫描结束以后，再将这些记录过引用关系的黑色对象作为根节点，重新扫描，所以在重新扫描完以后，可以理解为黑色对象变为了灰色对象，因为灰色对象代表垃圾回收期扫描过你，但是你还指向一个或多个白色对象的引用关系

而原始快照的原理是破坏第二个条件，当灰色对象要删除指向白色对象的引用关系时，将这个记录下来，在并发扫描结束以后，再以记录过的灰色节点为根重新扫描。

cms在并发标记阶段是使用增量更新，而shen和G1是使用原始快照的方式来进行并发标记。

### G1

G1垃圾回收器的出现主要是一种思想上的转变：在G1出现之前，所有的回收器要么只收集新生代，要么只收集老年代，而G1是第一款面向整堆收集的垃圾回收器，这种思想的转变，最终落地为了实现是基于region的分区式内存布局，虽然G1也遵循分代设计理论，但是它的堆内存布局与其他的有明显区别，G1不再坚持固定大小以及固定数量的分代区域划分，而是把堆内存划分为多个大小相等的独立的区域，region，每一个region都可以根据需要，来扮演新生代eden区，survivor区最早或者老年代。收集器最终根据不同的策略去处理。

G1的收集步骤主要是：

1.初始标记：仅仅记录下GCroots能直接关联到的对象，并且修改TAMS指针，让下一阶段用户线程并发执行时，能正确的在可用的region上分配新对象，这个阶段需要停顿线程，但是耗时很短的。

2.并发标记：从GCroots开始对堆中对象进行可达性分析，递归扫描整个图结构，找出需要回收的对象，这部分的耗时较长，但可与用户线程并发执行，当扫描完成后，还需要处理原始快照中的记录，重新扫描以灰色对象为根的图，从而解决并发标记下对象消失问题

3.最终标记：对用户线程做一个短暂的暂停，用于处理并发标记阶段遗留下来的原始快照中的记录。

4.筛选回收：负责更新region中的记录，对各个region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以选择任意多个region构成回收集，然后把回收集中的region中的存活对象移到空region中，从而清除整个旧region，这里操作涉及对象的移动，所以需要暂停用户线程

G1在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值大的region，这也是它名字的的由来

G1从整体上来看是标记-整体算法，从局部，两个region之间是标记-复制算法，这两种算法都意味着G1不会出现内存空间碎片，所以对象访问方式应该是指针碰撞，同时呢这样子也不容易因为大对象无法找到足够大的连续内存空间而导致提前触发下一次GC

G1是jdk9的默认垃圾回收器，如果要在jdk8开启，需要设置的参数为:

-XX:+UseG1GC -XX:+PrintCommandLineFlags

在项目中尝试使用了G1垃圾回收器，并设置初始堆与最大堆容量都为256MB，使用jmter设置线程数200，ramp-up为1s，循环次数为永久，样本为20000，进行了简单的压测，测试结果与jdk8默认垃圾回收器设置下基本相同，但是通过观察jvisualvm的gc折线图，发现使用G1在old gen的回收次数很少，并且只有一个s1区，s0区一直为空，eden和s1是回收的主力区

由此案例可以在一定程度上说明，垃圾回收期更准确的一个叫法是自动内存管理子系统，它不仅需要做好垃圾回收的本职工作，还需要对堆内存的管理与布局，对象的分配等等工作。

### 对象动态年龄判断

其实并不是所有在s区的对象年龄达到默认的15或者达到自己设定的阈值才进入老年代，虚拟机有动态对象年龄计算算法，如果s区中的对象年龄在某个年龄阈值以下的所有对象的占用空间达到了s区内存的一半以上，那么就会以这个年龄为阈值，大于等于这个年龄的对象就会被送入老年代

### 空间分配担保

在发生新生代GC，也就是MinorGC前，虚拟机会判断老年代的最大可用连续空间是否大于新生代所有对象的总和，如果大于，才可以放心的进行minorgc。空间担保机制它担保的风险具体说是：由于新生代采用的是复制算法，同时为了节约内存考虑，并没有直接使用半区复制，而是在此基础上做了默认八比1比1的内存分配，这样子的话只使用了一个s区进行轮换，那么最坏的情况的是如果一次minorgc后新生代对象都是存活的，那么新来的对象就需要在s区无法容纳， 就需要直接进入老年代，老年代要进行这样的一个担保工作，但是前提是你得能存下新生代所有的对象总和，这是一种最坏情况，取历史平均值的话也是一种赌博的思想。